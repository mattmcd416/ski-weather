<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚õ∑Ô∏è Ski Mountain Forecast Analyzer</title>

  <!-- Dependencies -->
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>

  <style>
    * {
      box-sizing: border-box;
    }

    * {
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      margin: 0;
      padding: 0;
      background: #f0f4f8;
      padding-bottom: 50px;
    }

    .container {
      max-width: 98%;
      margin: 0 auto;
      padding: 0 10px;
    }

    /* Top Form - Sticky */
    #top-form {
      position: sticky;
      top: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    #top-form h1 {
      margin: 0;
      font-size: 24px;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .form-row {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }

    .top-form-content {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .form-group label {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .form-group input,
    .form-group select,
    .form-group button {
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
    }

    .btn {
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }

    .btn-primary {
      background: #10b981;
      color: white;
    }

    .btn-primary:hover {
      background: #059669;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .btn-secondary {
      background: #3b82f6;
      color: white;
    }

    .btn-secondary:hover {
      background: #2563eb;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    /* Progress Bar */
    #progress-container {
      display: none;
      margin-top: 10px;
      background: rgba(255,255,255,0.3);
      border-radius: 10px;
      overflow: hidden;
      position: relative;
      height: 30px;
    }

    #progress-bar {
      height: 30px;
      background: #10b981;
      width: 0%;
      transition: width 0.3s;
    }

    #progress-text {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      pointer-events: none;
    }

    /* Mountain Manager */
    #mountain-manager {
      background: white;
      padding: 25px;
      margin: 20px auto;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: none;
    }

    #mountain-manager h2 {
      margin-top: 0;
      color: #1f2937;
    }

    .mountain-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .mountain-table th,
    .mountain-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }

    .mountain-table th {
      background: #f9fafb;
      font-weight: 600;
      color: #374151;
    }

    .mountain-table tr:hover {
      background: #f9fafb;
    }

    .mountain-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin: 20px 0;
      padding: 20px;
      background: #f9fafb;
      border-radius: 8px;
    }

    .mountain-form input {
      padding: 8px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
    }

    /* Results Section */
    #results {
      margin-top: 20px;
    }

    .winner-box {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      color: #78350f;
      padding: 20px 25px;
      margin: 20px auto;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: flex;
      align-items: center;
      gap: 30px;
    }

    .winner-box h2 {
      margin: 0;
      font-size: 28px;
      white-space: nowrap;
      min-width: fit-content;
    }

    .pros-cons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      flex: 1;
    }

    .pros-cons h3 {
      margin-top: 0;
    }

    .pros-cons ul {
      margin: 10px 0;
      padding-left: 20px;
    }

    .pros-cons li {
      margin: 8px 0;
    }

    /* Carousel Container */
    .carousel-container {
      position: relative;
      margin: 20px auto;
      overflow: hidden;
      width: 100%;
    }

    .carousel-track {
      display: flex;
      transition: transform 0.3s ease-in-out;
      width: 100%;
    }

    /* Day Box */
    .day-box {
      background: transparent;
      margin: 0;
      flex-shrink: 0;
      flex-grow: 0;
      box-sizing: border-box;
    }

    /* Carousel Navigation */
    .carousel-nav {
      position: fixed;
      top: 50vh;
      transform: translateY(-50%);
      background: rgba(102, 126, 234, 0.9);
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      z-index: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
    }

    .carousel-nav:hover {
      background: rgba(102, 126, 234, 1);
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .carousel-nav:disabled {
      background: rgba(156, 163, 175, 0.5);
      cursor: not-allowed;
      opacity: 0.5;
    }

    .carousel-nav:disabled:hover {
      transform: translateY(-50%);
    }

    .carousel-nav-left {
      left: 20px;
    }

    .carousel-nav-right {
      right: 20px;
    }

    /* Carousel Indicators */
    .carousel-indicators {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
    }

    .carousel-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #d1d5db;
      border: none;
      cursor: pointer;
      transition: all 0.3s;
    }

    .carousel-indicator.active {
      background: #667eea;
      width: 32px;
      border-radius: 6px;
    }

    .carousel-indicator:hover:not(.active) {
      background: #9ca3af;
    }

    /* Responsive Carousel */
    @media (max-width: 768px) {
      .carousel-nav {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }

      .carousel-nav-left {
        left: 10px;
      }

      .carousel-nav-right {
        right: 10px;
      }

      .carousel-indicator {
        width: 10px;
        height: 10px;
      }

      .carousel-indicator.active {
        width: 24px;
      }
    }

    .day-header {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      padding: 15px 25px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 16px;
      font-weight: 600;
      white-space: nowrap;
      border-radius: 12px 12px 0 0;
      margin-bottom: 0;
      width: 100%;
      box-sizing: border-box;
    }

    .day-content {
      background: white;
      border-radius: 0 0 12px 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      width: 100%;
      overflow: hidden;
    }

    .comparison-table-wrapper {
      position: relative;
      width: 100%;
      overflow-x: auto;
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;
      min-width: 800px;
    }

    .comparison-table th {
      background: #1f2937;
      color: white;
      padding: 12px 8px;
      text-align: left;
      font-size: 12px;
      border-right: 1px solid #374151;
    }

    .comparison-table th:first-child,
    .comparison-table td:first-child {
      width: 20%;
      min-width: 180px;
    }

    .comparison-table td {
      padding: 12px 8px;
      border-bottom: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
    }

    .comparison-table tr:hover {
      background: #f9fafb;
    }

    .score {
      font-weight: 700;
      font-size: 18px;
      color: #10b981;
    }

    .charts-container {
      padding: 25px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      border-radius: 0 0 12px 12px;
      width: 100%;
      box-sizing: border-box;
    }

    .chart-wrapper {
      background: #f9fafb;
      padding: 15px;
      border-radius: 8px;
      position: relative;
      min-width: 0;
      min-height: 0;
    }

    .chart-wrapper canvas {
      max-height: 480px;
    }

    .chart-title {
      font-weight: 600;
      margin-bottom: 10px;
      color: #1f2937;
    }

    /* Modal for errors */
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    .modal-content {
      background-color: white;
      margin: 15% auto;
      padding: 30px;
      border-radius: 12px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover {
      color: #000;
    }

    /* Small buttons */
    .btn-sm {
      padding: 5px 10px;
      font-size: 12px;
    }

    /* Utility */
    .text-center {
      text-align: center;
    }

    .mt-2 {
      margin-top: 20px;
    }

    /* Threshold highlighting */
    .warning-yellow {
      background-color: rgba(234, 179, 8, 0.3) !important;
    }

    .warning-red {
      background-color: rgba(239, 68, 68, 0.3) !important;
    }

    /* Landing Page */
    #landing-page {
      background: white;
      padding: 40px;
      margin: 40px auto;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
      max-width: 900px;
    }

    #landing-page h2 {
      color: #667eea;
      margin-top: 0;
      font-size: 32px;
      text-align: center;
    }

    #landing-page h3 {
      color: #1f2937;
      margin-top: 30px;
      margin-bottom: 15px;
      font-size: 20px;
    }

    #landing-page p {
      color: #4b5563;
      line-height: 1.6;
      margin: 10px 0;
    }

    #landing-page ol, #landing-page ul {
      color: #4b5563;
      line-height: 1.8;
      margin: 15px 0;
    }

    #landing-page li {
      margin: 8px 0;
    }

    #landing-page .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 30px 0;
    }

    #landing-page .feature-card {
      background: #f9fafb;
      padding: 20px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    #landing-page .feature-card h4 {
      margin-top: 0;
      color: #667eea;
    }

    #landing-page .cta-button {
      display: inline-block;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 30px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      margin: 20px auto;
      text-align: center;
      cursor: pointer;
      border: none;
      font-size: 16px;
    }

    #landing-page .cta-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
  </style>
</head>
<body>
<!-- Top Form -->
<div id="top-form">
  <div class="container">
    <div class="top-form-content">
      <h1>‚õ∑Ô∏è Ski Mountain Forecast Analyzer</h1>
      <button class="btn btn-secondary" id="toggle-mountain-manager" style="font-size: 14px; padding: 8px 12px;">üèîÔ∏è Mountain Manager</button>
      <div class="form-group">
        <label>üìÖ Start Date</label>
        <input type="text" id="start-date" readonly>
      </div>
      <div class="form-group">
        <label>üìÖ End Date</label>
        <input type="text" id="end-date" readonly>
      </div>
      <button class="btn btn-secondary" id="this-weekend" style="margin-top: 20px;">This Weekend</button>
      <button class="btn btn-secondary" id="next-weekend" style="margin-top: 20px;">Next Weekend</button>
      <div class="form-group">
        <label>üèîÔ∏è Elevation</label>
        <select id="elevation-select">
          <option value="base">Base</option>
          <option value="mid" selected>Mid-Mountain</option>
          <option value="peak">Peak</option>
        </select>
      </div>
      <button class="btn btn-primary" id="load-forecast" style="margin-top: 20px;">üîÆ Load Forecast</button>
    </div>
    <div id="progress-container">
      <div id="progress-bar"></div>
      <div id="progress-text">0%</div>
    </div>
  </div>
</div>

<!-- Mountain Manager -->
<div class="container">
  <!-- Landing Page -->
  <div id="landing-page">
    <h2>‚õ∑Ô∏è Welcome to Ski Mountain Forecast Analyzer</h2>

    <p style="text-align: center; font-size: 18px; margin-bottom: 30px;">
      Compare weather forecasts across multiple ski mountains to find the best conditions for your next ski trip!
    </p>

    <h3>üöÄ Quick Start Guide</h3>
    <ol>
      <li><strong>Add Mountains:</strong> Click the "üèîÔ∏è Mountain Manager" button in the header to add ski mountains. You can add them individually or use the "‚≠ê Add All Epic Northeast Mountains" button for quick setup.</li>
      <li><strong>Select Dates:</strong> Use the date pickers or quick buttons ("This Weekend" / "Next Weekend") to choose your ski dates.</li>
      <li><strong>Choose Elevation:</strong> Select Base, Mid-Mountain, or Peak to see forecasts at different elevations.</li>
      <li><strong>Load Forecast:</strong> Click "üîÆ Load Forecast" to fetch weather data and see detailed comparisons.</li>
    </ol>

    <h3>‚ú® Features</h3>
    <div class="feature-grid">
      <div class="feature-card">
        <h4>üèÜ Smart Scoring</h4>
        <p>Automatically calculates the best mountain based on temperature, snowfall, wind, and visibility.</p>
      </div>
      <div class="feature-card">
        <h4>üìä Visual Charts</h4>
        <p>See hour-by-hour weather trends with interactive charts for each metric.</p>
      </div>
      <div class="feature-card">
        <h4>‚ùÑÔ∏è Freeze-Thaw Analysis</h4>
        <p>Track freeze-thaw cycles to understand ice conditions.</p>
      </div>
      <div class="feature-card">
        <h4>üéØ Threshold Warnings</h4>
        <p>Color-coded alerts for dangerous conditions like extreme cold or high winds.</p>
      </div>
    </div>

    <h3>üí° Tips</h3>
    <ul>
      <li>Click on any chart legend or line to solo that mountain's data</li>
      <li>The app compares all mountains side-by-side for each day</li>
      <li>Yellow/red highlighting in tables indicates warning conditions</li>
      <li>Your mountain list is saved automatically in your browser</li>
    </ul>

    <div style="text-align: center; margin-top: 40px;">
      <button class="cta-button" onclick="$('#toggle-mountain-manager').click(); $('#landing-page').slideUp(300);">
        üèîÔ∏è Get Started - Add Mountains
      </button>
    </div>
  </div>

  <div id="mountain-manager">
    <h2>üèîÔ∏è Mountain Manager</h2>

    <div class="mountain-form">
      <input type="text" id="new-name" placeholder="Mountain Name">
      <input type="number" step="0.0001" id="new-lat" placeholder="Latitude">
      <input type="number" step="0.0001" id="new-lng" placeholder="Longitude">
      <input type="number" id="new-base" placeholder="Base Elevation (ft)">
      <input type="number" id="new-peak" placeholder="Peak Elevation (ft)">
      <button class="btn btn-primary" id="add-mountain">‚ûï Add Mountain</button>
    </div>

    <button class="btn btn-secondary mt-2" id="add-epic-northeast">‚≠ê Add All Epic Northeast Mountains</button>

    <div style="overflow-x: auto;">
      <table class="mountain-table">
        <thead>
        <tr>
          <th>Mountain Name</th>
          <th>Latitude</th>
          <th>Longitude</th>
          <th>Base (ft)</th>
          <th>Peak (ft)</th>
          <th>Mid (ft)</th>
          <th>Actions</th>
        </tr>
        </thead>
        <tbody id="mountains-tbody">
        </tbody>
      </table>
    </div>
  </div>

  <!-- Results -->
  <div id="results"></div>
</div>

<!-- Error Modal -->
<div id="error-modal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>‚ùå Error</h2>
    <p id="error-message"></p>
  </div>
</div>

<script>
  // Global state
  let mountains = [];
  let weatherData = {};
  let charts = {};
  let activeSeries = null;
  let editingIndex = null;
  let currentDayIndex = 0;
  let totalDays = 0;

  // Epic Northeast Mountains Data
  const EPIC_NORTHEAST_MOUNTAINS = [
    { name: 'Stowe Mountain Resort', lat: 44.5304, lng: -72.7875, base: 1600, peak: 3625 },
    { name: 'Okemo Mountain Resort', lat: 43.4018, lng: -72.7159, base: 1194, peak: 3343 },
    { name: 'Mount Snow', lat: 42.9604, lng: -72.9201, base: 1900, peak: 3600 },
    { name: 'Wildcat Mountain', lat: 44.2626, lng: -71.2321, base: 1974, peak: 4062 },
    { name: 'Attitash Mountain Resort', lat: 44.0854, lng: -71.2511, base: 950, peak: 2350 },
    { name: 'Mount Sunapee Resort', lat: 43.3359, lng: -72.0833, base: 1035, peak: 2743 },
    { name: 'Crotched Mountain', lat: 43.0127, lng: -71.8715, base: 1155, peak: 2066 }
  ];

  // Initialize
  $(document).ready(function() {
    initializeDatePickers();
    loadMountains();
    renderMountainsTable();
    setThisWeekend();

    // Event listeners
    $('#this-weekend').click(setThisWeekend);
    $('#next-weekend').click(setNextWeekend);
    $('#add-mountain').click(addMountain);
    $('#add-epic-northeast').click(addEpicNortheastMountains);
    $('#load-forecast').click(loadForecast);
    $('#elevation-select').change(updateElevationDisplay);
    $('#toggle-mountain-manager').click(toggleMountainManager);
    $('.close').click(() => $('#error-modal').hide());
  });

  // Date picker initialization
  function initializeDatePickers() {
    $('#start-date, #end-date').datepicker({
      dateFormat: 'yy-mm-dd',
      minDate: 0
    });
  }

  // Weekend functions
  function setThisWeekend() {
    const today = new Date();
    const dayOfWeek = today.getDay();
    const daysUntilFriday = (5 - dayOfWeek + 7) % 7;
    const friday = new Date(today);
    friday.setDate(today.getDate() + daysUntilFriday);

    const sunday = new Date(friday);
    sunday.setDate(friday.getDate() + 2);

    $('#start-date').val(formatDate(friday));
    $('#end-date').val(formatDate(sunday));
  }

  function setNextWeekend() {
    const today = new Date();
    const dayOfWeek = today.getDay();
    const daysUntilFriday = ((5 - dayOfWeek + 7) % 7) + 7;
    const friday = new Date(today);
    friday.setDate(today.getDate() + daysUntilFriday);

    const sunday = new Date(friday);
    sunday.setDate(friday.getDate() + 2);

    $('#start-date').val(formatDate(friday));
    $('#end-date').val(formatDate(sunday));
  }

  function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // Mountain management
  function loadMountains() {
    const stored = localStorage.getItem('mountains');
    if (stored) {
      mountains = JSON.parse(stored);
    }
  }

  function saveMountains() {
    localStorage.setItem('mountains', JSON.stringify(mountains));
  }

  function addMountain() {
    const name = $('#new-name').val().trim();
    const lat = parseFloat($('#new-lat').val());
    const lng = parseFloat($('#new-lng').val());
    const base = parseInt($('#new-base').val());
    const peak = parseInt($('#new-peak').val());

    if (!name || isNaN(lat) || isNaN(lng) || isNaN(base) || isNaN(peak)) {
      showError('Please fill in all mountain fields with valid values');
      return;
    }

    mountains.push({ name, lat, lng, base, peak });
    saveMountains();
    renderMountainsTable();

    // Clear form
    $('#new-name, #new-lat, #new-lng, #new-base, #new-peak').val('');
  }

  function addEpicNortheastMountains() {
    mountains = [...EPIC_NORTHEAST_MOUNTAINS];
    saveMountains();
    renderMountainsTable();
  }

  function deleteMountain(index) {
    if (confirm(`Delete ${mountains[index].name}?`)) {
      mountains.splice(index, 1);
      saveMountains();
      renderMountainsTable();
    }
  }

  function editMountain(index) {
    editingIndex = index;
    renderMountainsTable();
  }

  function saveMountainEdit(index) {
    const name = $(`#edit-name-${index}`).val().trim();
    const lat = parseFloat($(`#edit-lat-${index}`).val());
    const lng = parseFloat($(`#edit-lng-${index}`).val());
    const base = parseInt($(`#edit-base-${index}`).val());
    const peak = parseInt($(`#edit-peak-${index}`).val());

    if (!name || isNaN(lat) || isNaN(lng) || isNaN(base) || isNaN(peak)) {
      showError('Please fill in all fields with valid values');
      return;
    }

    mountains[index] = { name, lat, lng, base, peak };
    saveMountains();
    editingIndex = null;
    renderMountainsTable();
  }

  function cancelMountainEdit() {
    editingIndex = null;
    renderMountainsTable();
  }

  function renderMountainsTable() {
    const tbody = $('#mountains-tbody');
    tbody.empty();

    mountains.forEach((m, idx) => {
      const mid = Math.round((m.peak + m.base) / 2);

      if (editingIndex === idx) {
        // Render editable row
        const row = $(`
                    <tr style="background: #fef3c7;">
                        <td><input type="text" id="edit-name-${idx}" value="${m.name}" style="width: 100%; padding: 4px;"></td>
                        <td><input type="number" step="0.0001" id="edit-lat-${idx}" value="${m.lat}" style="width: 100%; padding: 4px;"></td>
                        <td><input type="number" step="0.0001" id="edit-lng-${idx}" value="${m.lng}" style="width: 100%; padding: 4px;"></td>
                        <td><input type="number" id="edit-base-${idx}" value="${m.base}" style="width: 100%; padding: 4px;"></td>
                        <td><input type="number" id="edit-peak-${idx}" value="${m.peak}" style="width: 100%; padding: 4px;"></td>
                        <td>${mid}</td>
                        <td>
                            <button class="btn btn-primary btn-sm" onclick="saveMountainEdit(${idx})">üíæ Save</button>
                            <button class="btn btn-secondary btn-sm" onclick="cancelMountainEdit()">‚ùå Cancel</button>
                        </td>
                    </tr>
                `);
        tbody.append(row);
      } else {
        // Render normal row
        const row = $(`
                    <tr>
                        <td>${m.name}</td>
                        <td>${m.lat.toFixed(4)}</td>
                        <td>${m.lng.toFixed(4)}</td>
                        <td>${m.base}</td>
                        <td>${m.peak}</td>
                        <td>${mid}</td>
                        <td>
                            <button class="btn btn-secondary btn-sm" onclick="editMountain(${idx})">‚úèÔ∏è Edit</button>
                            <button class="btn btn-danger btn-sm" onclick="deleteMountain(${idx})">üóëÔ∏è Delete</button>
                        </td>
                    </tr>
                `);
        tbody.append(row);
      }
    });
  }

  // Weather fetching
  async function loadForecast() {
    if (mountains.length === 0) {
      showError('Please add at least one mountain first');
      return;
    }

    const startDate = $('#start-date').val();
    const endDate = $('#end-date').val();

    if (!startDate || !endDate) {
      showError('Please select start and end dates');
      return;
    }

    // Calculate date range including 7 days prior for freeze-thaw analysis
    const start = new Date(startDate);
    const historicStart = new Date(start);
    historicStart.setDate(start.getDate() - 7);
    const historicStartStr = formatDate(historicStart);

    $('#progress-container').show();
    $('#progress-bar').css('width', '0%');
    $('#progress-text').text('0%');
    weatherData = {};

    try {
      for (let i = 0; i < mountains.length; i++) {
        const mountain = mountains[i];
        const progress = Math.round(((i + 1) / mountains.length) * 100);
        $('#progress-bar').css('width', progress + '%');
        $('#progress-text').text(`Loading ${mountain.name}... ${progress}%`);

        const data = await fetchWeatherForMountain(mountain, historicStartStr, endDate);
        weatherData[mountain.name] = data;
      }

      renderResults(startDate, endDate);
      $('#progress-container').hide();
      $('#landing-page').slideUp(300);
    } catch (error) {
      $('#progress-container').hide();
      showError(`Failed to load forecast: ${error.message}`);
    }
  }

  async function fetchWeatherForMountain(mountain, startDate, endDate) {
    const mid = Math.round((mountain.peak + mountain.base) / 2);

    // Fetch data for all three elevations
    const elevations = {
      base: mountain.base,
      mid: mid,
      peak: mountain.peak
    };

    const results = {};

    for (const [key, elevation] of Object.entries(elevations)) {
      const url = buildOpenMeteoUrl(mountain.lat, mountain.lng, elevation, startDate, endDate);
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`Failed to fetch weather for ${mountain.name} at ${key} elevation: ${response.statusText}`);
      }

      const data = await response.json();
      results[key] = data;
    }

    return results;
  }

  function buildOpenMeteoUrl(lat, lng, elevation, startDate, endDate) {
    // Convert feet to meters (API expects meters)
    const elevationMeters = Math.round(elevation * 0.3048);
    const params = new URLSearchParams({
      latitude: lat,
      longitude: lng,
      elevation: elevationMeters,
      start_date: startDate,
      end_date: endDate,
      hourly: [
        'temperature_2m',
        'apparent_temperature',
        'precipitation',
        'rain',
        'snowfall',
        'weather_code',
        'cloud_cover',
        'visibility',
        'wind_speed_10m',
        'wind_direction_10m',
        'wind_gusts_10m'
      ].join(','),
      temperature_unit: 'fahrenheit',
      wind_speed_unit: 'mph',
      precipitation_unit: 'inch',
      timezone: 'America/New_York'
    });

    return `https://api.open-meteo.com/v1/forecast?${params}`;
  }

  // Results rendering
  function renderResults(startDate, endDate) {
    const results = $('#results');
    results.empty();

    // Destroy existing charts
    Object.values(charts).forEach(chart => chart.destroy());
    charts = {};

    // Calculate overall winner
    const overallWinner = calculateOverallWinner(startDate, endDate);
    renderOverallWinner(overallWinner);

    // Create carousel structure
    const carouselContainer = $('<div class="carousel-container"></div>');
    const carouselTrack = $('<div class="carousel-track"></div>');

    // Create navigation buttons
    const leftButton = $('<button class="carousel-nav carousel-nav-left" id="carousel-prev">‚Äπ</button>');
    const rightButton = $('<button class="carousel-nav carousel-nav-right" id="carousel-next">‚Ä∫</button>');

    carouselContainer.append(leftButton);
    carouselContainer.append(carouselTrack);
    carouselContainer.append(rightButton);

    results.append(carouselContainer);

    // Collect all dates
    const dates = [];
    const start = new Date(startDate + 'T12:00:00');
    const end = new Date(endDate + 'T12:00:00');
    const currentDate = new Date(start);

    while (currentDate <= end) {
      const dateStr = formatDate(currentDate);
      if (dateStr >= startDate && dateStr <= endDate) {
        dates.push({ dateStr, dateObj: new Date(currentDate) });
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }

    // Render each day into the carousel track
    dates.forEach(({ dateStr, dateObj }) => {
      renderDayBox(dateStr, dateObj, carouselTrack);
    });

    // Set up carousel state
    currentDayIndex = 0;
    totalDays = dates.length;

    // Set carousel track width to accommodate all days
    carouselTrack.css('width', `${totalDays * 100}%`);

    // Set each day-box width to be proportional to the track
    $('.day-box').each(function() {
      $(this).css('width', `${100 / totalDays}%`);
    });

    // Create indicators
    const indicators = $('<div class="carousel-indicators"></div>');
    for (let i = 0; i < totalDays; i++) {
      const indicator = $(`<button class="carousel-indicator ${i === 0 ? 'active' : ''}" data-index="${i}"></button>`);
      indicator.click(() => goToDay(i));
      indicators.append(indicator);
    }
    results.append(indicators);

    // Set up navigation handlers
    $('#carousel-prev').click(() => navigateCarousel(-1));
    $('#carousel-next').click(() => navigateCarousel(1));

    // Keyboard navigation
    $(document).off('keydown.carousel').on('keydown.carousel', function(e) {
      if (e.key === 'ArrowLeft') {
        navigateCarousel(-1);
      } else if (e.key === 'ArrowRight') {
        navigateCarousel(1);
      }
    });

    // Update navigation buttons
    updateCarouselNav();

    // Set up touch/swipe support
    setupTouchSupport();

    // Force chart resize after carousel setup (using setTimeout to ensure DOM is ready)
    setTimeout(() => {
      Object.values(charts).forEach(chart => {
        if (chart && chart.resize) {
          chart.resize();
        }
      });
    }, 100);
  }

  function calculateOverallWinner(startDate, endDate) {
    const scores = {};
    const reasonings = {};

    mountains.forEach(mountain => {
      let totalScore = 0;
      let count = 0;
      const pros = [];
      const cons = [];

      const start = new Date(startDate);
      const end = new Date(endDate);

      for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
        const dateStr = formatDate(d);
        const dayScore = calculateDayScore(mountain, dateStr);
        totalScore += dayScore.score;
        count++;
      }

      const avgScore = totalScore / count;
      scores[mountain.name] = avgScore;

      // Analyze overall conditions
      const elevation = $('#elevation-select').val();
      const data = weatherData[mountain.name][elevation].hourly;

      // Calculate aggregate metrics
      let totalSnow = 0;
      let totalRain = 0;
      let avgTemp = 0;
      let maxWind = 0;
      let avgVisibility = 0;
      let tempCount = 0;

      data.time.forEach((time, idx) => {
        const date = time.split('T')[0];
        if (date >= startDate && date <= endDate) {
          const hour = parseInt(time.split('T')[1].split(':')[0]);
          if (hour >= 9 && hour <= 16) {
            totalSnow += data.snowfall[idx] || 0;
            totalRain += data.rain[idx] || 0;
            avgTemp += data.temperature_2m[idx] || 0;
            maxWind = Math.max(maxWind, data.wind_speed_10m[idx] || 0);
            avgVisibility += data.visibility[idx] || 0;
            tempCount++;
          }
        }
      });

      avgTemp /= tempCount;
      avgVisibility /= tempCount;

      // Determine pros
      if (totalSnow > 3) pros.push(`üå®Ô∏è Excellent snowfall: ${totalSnow.toFixed(1)}" expected`);
      else if (totalSnow > 1) pros.push(`‚ùÑÔ∏è Good snowfall: ${totalSnow.toFixed(1)}" expected`);

      if (avgTemp >= 20 && avgTemp <= 32) pros.push(`üå°Ô∏è Perfect skiing temps: ${avgTemp.toFixed(0)}¬∞F average`);
      else if (avgTemp > 32 && avgTemp <= 40) pros.push(`‚òÄÔ∏è Mild temperatures: ${avgTemp.toFixed(0)}¬∞F average`);

      if (maxWind < 15) pros.push(`üí® Low wind speeds: max ${maxWind.toFixed(0)} mph`);
      else if (maxWind < 25) pros.push(`üçÉ Moderate winds: max ${maxWind.toFixed(0)} mph`);

      if (avgVisibility > 15000) pros.push(`üëÅÔ∏è Excellent visibility: ${(avgVisibility/5280).toFixed(1)} miles`);

      // Determine cons
      if (totalSnow < 0.5 && totalRain < 0.5) cons.push(`üèúÔ∏è Limited precipitation: ${(totalSnow + totalRain).toFixed(1)}" total`);

      if (totalRain > 0.5) cons.push(`üåßÔ∏è Rain expected: ${totalRain.toFixed(1)}"`);

      if (avgTemp < 10) cons.push(`ü•∂ Very cold temps: ${avgTemp.toFixed(0)}¬∞F average`);
      else if (avgTemp > 40) cons.push(`üî• Warm temps may soften snow: ${avgTemp.toFixed(0)}¬∞F average`);

      if (maxWind > 25) cons.push(`üí® High winds: gusts up to ${maxWind.toFixed(0)} mph`);
      else if (maxWind > 35) cons.push(`‚ö†Ô∏è Very high winds: gusts up to ${maxWind.toFixed(0)} mph`);

      if (avgVisibility < 5000) cons.push(`üå´Ô∏è Poor visibility: ${(avgVisibility/5280).toFixed(1)} miles`);

      reasonings[mountain.name] = { pros, cons };
    });

    // Find winner
    let winner = null;
    let maxScore = -1;

    for (const [name, score] of Object.entries(scores)) {
      if (score > maxScore) {
        maxScore = score;
        winner = name;
      }
    }

    return {
      name: winner,
      score: maxScore,
      pros: reasonings[winner].pros,
      cons: reasonings[winner].cons
    };
  }

  function renderOverallWinner(winner) {
    const html = $(`
                <div class="winner-box">
                    <h2>üèÜ Overall Winner: ${winner.name}</h2>
                    <div class="pros-cons">
                        <div>
                            <h3>‚úÖ Pros</h3>
                            <ul>
                                ${winner.pros.map(p => `<li>${p}</li>`).join('')}
                            </ul>
                        </div>
                        <div>
                            <h3>‚ö†Ô∏è Cons</h3>
                            <ul>
                                ${winner.cons.length > 0 ? winner.cons.map(c => `<li>${c}</li>`).join('') : '<li>No significant drawbacks!</li>'}
                            </ul>
                        </div>
                    </div>
                </div>
            `);

    $('#results').append(html);
  }

  function renderDayBox(dateStr, dateObj, container) {
    const dayName = dateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });

    // Calculate day winner
    const dayWinner = calculateDayWinner(dateStr);

    const boxId = `day-${dateStr}`;
    const box = $(`
                <div class="day-box" id="${boxId}">
                    <div class="day-header">
                        üìÜ ${dayName} &nbsp;&nbsp;&nbsp; ü•á Winner: ${dayWinner.name} (Score: ${dayWinner.score.toFixed(1)}/100) &nbsp;&nbsp;&nbsp; Why it won: ${dayWinner.reason}
                    </div>
                    <div class="day-content">
                        <div class="comparison-table-wrapper">
                            <table class="comparison-table" id="table-${dateStr}">
                            </table>
                        </div>
                        <div class="charts-container" id="charts-${dateStr}">
                        </div>
                    </div>
                </div>
            `);

    container.append(box);
    renderComparisonTable(dateStr);
    renderCharts(dateStr);
  }

  function calculateDayWinner(dateStr) {
    const scores = {};
    const reasons = {};

    mountains.forEach(mountain => {
      const result = calculateDayScore(mountain, dateStr);
      scores[mountain.name] = result.score;
      reasons[mountain.name] = result.reason;
    });

    let winner = null;
    let maxScore = -1;

    for (const [name, score] of Object.entries(scores)) {
      if (score > maxScore) {
        maxScore = score;
        winner = name;
      }
    }

    return {
      name: winner,
      score: maxScore,
      reason: reasons[winner]
    };
  }

  function calculateDayScore(mountain, dateStr) {
    const elevation = $('#elevation-select').val();
    const data = weatherData[mountain.name][elevation].hourly;

    // Extract ski hours (9am-4pm) for this date
    const skiData = {
      temps: [],
      apparentTemps: [],
      winds: [],
      gusts: [],
      snowfall: 0,
      rain: 0,
      visibility: []
    };

    data.time.forEach((time, idx) => {
      if (time.startsWith(dateStr)) {
        const hour = parseInt(time.split('T')[1].split(':')[0]);
        if (hour >= 9 && hour <= 16) {
          skiData.temps.push(data.temperature_2m[idx] || 0);
          skiData.apparentTemps.push(data.apparent_temperature[idx] || 0);
          skiData.winds.push(data.wind_speed_10m[idx] || 0);
          skiData.gusts.push(data.wind_gusts_10m[idx] || 0);
          skiData.snowfall += data.snowfall[idx] || 0;
          skiData.rain += data.rain[idx] || 0;
          skiData.visibility.push(data.visibility[idx] || 0);
        }
      }
    });

    let score = 50; // Base score
    const reasons = [];

    // Temperature scoring (ideal: 20-32¬∞F)
    const avgTemp = skiData.temps.reduce((a, b) => a + b, 0) / skiData.temps.length;
    if (avgTemp >= 20 && avgTemp <= 32) {
      score += 15;
      reasons.push('ideal temps');
    } else if (avgTemp > 32 && avgTemp <= 40) {
      score += 10;
    } else if (avgTemp < 10) {
      score -= 15;
      reasons.push('very cold');
    } else if (avgTemp > 40) {
      score -= 10;
    }

    // Snowfall scoring
    if (skiData.snowfall > 3) {
      score += 20;
      reasons.push(`${skiData.snowfall.toFixed(1)}" snow`);
    } else if (skiData.snowfall > 1) {
      score += 15;
      reasons.push(`${skiData.snowfall.toFixed(1)}" snow`);
    } else if (skiData.snowfall > 0.5) {
      score += 10;
    }

    // Rain penalty
    if (skiData.rain > 0.5) {
      score -= 20;
      reasons.push('rain expected');
    } else if (skiData.rain > 0.1) {
      score -= 10;
    }

    // Wind scoring (low is good)
    const maxWind = Math.max(...skiData.winds);
    if (maxWind < 10) {
      score += 10;
      reasons.push('calm winds');
    } else if (maxWind > 25) {
      score -= 15;
      reasons.push('high winds');
    } else if (maxWind > 35) {
      score -= 25;
    }

    // Visibility scoring
    const avgVisibility = skiData.visibility.reduce((a, b) => a + b, 0) / skiData.visibility.length;
    if (avgVisibility > 15000) {
      score += 5;
      reasons.push('great visibility');
    } else if (avgVisibility < 5000) {
      score -= 10;
    }

    // Clamp score to 0-100
    score = Math.max(0, Math.min(100, score));

    return {
      score,
      reason: reasons.length > 0 ? reasons.join(', ') : 'moderate conditions'
    };
  }

  function renderComparisonTable(dateStr) {
    const elevation = $('#elevation-select').val();
    const table = $(`#table-${dateStr}`);

    // Build header
    const header = $(`
                <thead>
                    <tr>
                        <th>Mountain</th>
                        <th>Feels Like (¬∞F)</th>
                        <th>Temp (¬∞F)</th>
                        <th>Wind Speed (mph)</th>
                        <th>Max Gust (mph)</th>
                        <th>Wind Dir</th>
                        <th>Snow (in)</th>
                        <th>Rain (in)</th>
                        <th>Freeze-Thaw Cycles (7d)</th>
                    </tr>
                </thead>
            `);
    table.append(header);

    const tbody = $('<tbody></tbody>');

    mountains.forEach(mountain => {
      const data = weatherData[mountain.name][elevation].hourly;
      const metrics = calculateDayMetrics(data, dateStr);
      const score = calculateDayScore(mountain, dateStr).score;
      const freezeThaw = calculateFreezeThawCycles(mountain);

      // Apply threshold highlighting
      const feelsLikeClass = getThresholdClass(metrics.feelsLikeMin, 'temp');
      const tempClass = getThresholdClass(metrics.tempMin, 'temp');
      const windClass = getThresholdClass(metrics.windMax, 'wind');
      const gustClass = getThresholdClass(metrics.maxGust, 'wind');

      const row = $(`
                    <tr>
                        <td><strong>${mountain.name}</strong></td>
                        <td class="${feelsLikeClass}">${metrics.feelsLikeMin.toFixed(0)} / ${metrics.feelsLikeMax.toFixed(0)}</td>
                        <td class="${tempClass}">${metrics.tempMin.toFixed(0)} / ${metrics.tempMax.toFixed(0)}</td>
                        <td class="${windClass}">${metrics.windMin.toFixed(0)} / ${metrics.windMax.toFixed(0)}</td>
                        <td class="${gustClass}">${metrics.maxGust.toFixed(0)}</td>
                        <td>${metrics.windDir}</td>
                        <td>${metrics.snow.toFixed(2)}</td>
                        <td>${metrics.rain.toFixed(2)}</td>
                        <td>${freezeThaw}</td>
                    </tr>
                `);
      tbody.append(row);
    });

    table.append(tbody);
  }

  function calculateDayMetrics(data, dateStr) {
    let feelsLikeMin = Infinity, feelsLikeMax = -Infinity;
    let tempMin = Infinity, tempMax = -Infinity;
    let windMin = Infinity, windMax = -Infinity;
    let maxGust = 0;
    let snow = 0, rain = 0;
    const windDirs = [];

    data.time.forEach((time, idx) => {
      if (time.startsWith(dateStr)) {
        const hour = parseInt(time.split('T')[1].split(':')[0]);
        if (hour >= 9 && hour <= 16) {
          feelsLikeMin = Math.min(feelsLikeMin, data.apparent_temperature[idx] || 0);
          feelsLikeMax = Math.max(feelsLikeMax, data.apparent_temperature[idx] || 0);
          tempMin = Math.min(tempMin, data.temperature_2m[idx] || 0);
          tempMax = Math.max(tempMax, data.temperature_2m[idx] || 0);
          windMin = Math.min(windMin, data.wind_speed_10m[idx] || 0);
          windMax = Math.max(windMax, data.wind_speed_10m[idx] || 0);
          maxGust = Math.max(maxGust, data.wind_gusts_10m[idx] || 0);
          snow += data.snowfall[idx] || 0;
          rain += data.rain[idx] || 0;
          windDirs.push(data.wind_direction_10m[idx]);
        }
      }
    });

    // Average wind direction
    const avgWindDir = windDirs.reduce((a, b) => a + b, 0) / windDirs.length;
    const windDir = degreesToCardinal(avgWindDir);

    return {
      feelsLikeMin, feelsLikeMax,
      tempMin, tempMax,
      windMin, windMax,
      maxGust, snow, rain,
      windDir
    };
  }

  function calculateFreezeThawCycles(mountain) {
    const elevation = $('#elevation-select').val();
    const data = weatherData[mountain.name][elevation].hourly;

    let cycles = 0;
    let wasFrozen = null;

    data.temperature_2m.forEach(temp => {
      if (temp !== null) {
        const isFrozen = temp <= 32;
        if (wasFrozen !== null && wasFrozen !== isFrozen) {
          if (!isFrozen) { // Thawed
            // Wait for it to freeze again to count as a cycle
          } else if (wasFrozen === false) { // Was thawed, now frozen
            cycles++;
          }
        }
        wasFrozen = isFrozen;
      }
    });

    return cycles;
  }

  function degreesToCardinal(degrees) {
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const index = Math.round(degrees / 45) % 8;
    return directions[index];
  }

  function getThresholdClass(value, type) {
    if (type === 'temp') {
      if (value <= -10) return 'warning-red';
      if (value <= 0) return 'warning-yellow';
    } else if (type === 'wind') {
      if (value >= 40) return 'warning-red';
      if (value >= 30) return 'warning-yellow';
    }
    return '';
  }

  function getYAxisMin(config, scales) {
    if (config.type === 'bar') return undefined;

    if (config.yAxisLabel === '¬∞F') {
      return scales.temp.min;
    } else if (config.yAxisLabel === 'mph') {
      return scales.wind.min;
    } else if (config.yAxisLabel === 'feet') {
      return scales.visibility.min;
    } else if (config.yAxisLabel === '%') {
      return scales.cloud.min;
    }
    return undefined;
  }

  function getYAxisMax(config, scales) {
    if (config.type === 'bar') return undefined;

    if (config.yAxisLabel === '¬∞F') {
      return scales.temp.max;
    } else if (config.yAxisLabel === 'mph') {
      return scales.wind.max;
    } else if (config.yAxisLabel === 'feet') {
      return scales.visibility.max;
    } else if (config.yAxisLabel === '%') {
      return scales.cloud.max;
    }
    return undefined;
  }

  function renderCharts(dateStr) {
    const container = $(`#charts-${dateStr}`);
    const elevation = $('#elevation-select').val();

    // Prepare time labels for this day (ski hours only)
    const sampleData = weatherData[mountains[0].name][elevation].hourly;
    const labels = [];
    const hourlyIndices = [];

    sampleData.time.forEach((time, idx) => {
      if (time.startsWith(dateStr)) {
        const timePart = time.split('T')[1];
        const hour = parseInt(timePart.split(':')[0]);
        labels.push(`${hour}:00`);
        hourlyIndices.push(idx);
      }
    });

    // Calculate shared y-axis scales for same-unit charts
    const scales = calculateSharedScales(dateStr, hourlyIndices, elevation);

    // Chart configurations
    const chartConfigs = [
      {
        id: `chart-feels-like-${dateStr}`,
        title: 'üå°Ô∏è Feels Like Temperature',
        type: 'line',
        dataKey: 'apparent_temperature',
        yAxisLabel: '¬∞F',
        backgroundColor: 'rgba(239, 68, 68, 0.2)',
        borderColor: 'rgba(239, 68, 68, 1)'
      },
      {
        id: `chart-temp-${dateStr}`,
        title: 'üå°Ô∏è Actual Temperature',
        type: 'line',
        dataKey: 'temperature_2m',
        yAxisLabel: '¬∞F',
        backgroundColor: 'rgba(249, 115, 22, 0.2)',
        borderColor: 'rgba(249, 115, 22, 1)'
      },
      {
        id: `chart-wind-${dateStr}`,
        title: 'üí® Wind Speed',
        type: 'line',
        dataKey: 'wind_speed_10m',
        yAxisLabel: 'mph',
        backgroundColor: 'rgba(59, 130, 246, 0.2)',
        borderColor: 'rgba(59, 130, 246, 1)'
      },
      {
        id: `chart-gusts-${dateStr}`,
        title: 'üí® Wind Gusts',
        type: 'line',
        dataKey: 'wind_gusts_10m',
        yAxisLabel: 'mph',
        backgroundColor: 'rgba(99, 102, 241, 0.2)',
        borderColor: 'rgba(99, 102, 241, 1)'
      },
      {
        id: `chart-cloud-${dateStr}`,
        title: '‚òÅÔ∏è Cloud Cover',
        type: 'line',
        dataKey: 'cloud_cover',
        yAxisLabel: '%',
        backgroundColor: 'rgba(156, 163, 175, 0.2)',
        borderColor: 'rgba(156, 163, 175, 1)'
      },
      {
        id: `chart-visibility-${dateStr}`,
        title: 'üëÅÔ∏è Visibility',
        type: 'line',
        dataKey: 'visibility',
        yAxisLabel: 'feet',
        backgroundColor: 'rgba(168, 85, 247, 0.2)',
        borderColor: 'rgba(168, 85, 247, 1)'
      },
      {
        id: `chart-snow-${dateStr}`,
        title: '‚ùÑÔ∏è Snowfall',
        type: 'bar',
        dataKey: 'snowfall',
        yAxisLabel: 'inches',
        backgroundColor: 'rgba(14, 165, 233, 0.6)',
        borderColor: 'rgba(14, 165, 233, 1)'
      },
      {
        id: `chart-rain-${dateStr}`,
        title: 'üåßÔ∏è Rainfall',
        type: 'bar',
        dataKey: 'rain',
        yAxisLabel: 'inches',
        backgroundColor: 'rgba(34, 197, 94, 0.6)',
        borderColor: 'rgba(34, 197, 94, 1)'
      }
    ];

    chartConfigs.forEach(config => {
      const wrapper = $(`
                    <div class="chart-wrapper">
                        <div class="chart-title">${config.title}</div>
                        <canvas id="${config.id}"></canvas>
                    </div>
                `);
      container.append(wrapper);

      createChart(config, dateStr, labels, hourlyIndices, scales);
    });
  }

  function calculateSharedScales(dateStr, hourlyIndices, elevation) {
    const scales = {
      temp: { min: Infinity, max: -Infinity },
      wind: { min: Infinity, max: -Infinity },
      cloud: { min: 0, max: 100 },
      visibility: { min: Infinity, max: -Infinity },
      precip: { min: 0, max: -Infinity }
    };

    mountains.forEach(mountain => {
      const data = weatherData[mountain.name][elevation].hourly;

      hourlyIndices.forEach(idx => {
        // Temperature (both actual and feels-like)
        const temp = data.temperature_2m[idx] || 0;
        const apparentTemp = data.apparent_temperature[idx] || 0;
        scales.temp.min = Math.min(scales.temp.min, temp, apparentTemp);
        scales.temp.max = Math.max(scales.temp.max, temp, apparentTemp);

        // Wind (both speed and gusts)
        const wind = data.wind_speed_10m[idx] || 0;
        const gust = data.wind_gusts_10m[idx] || 0;
        scales.wind.min = Math.min(scales.wind.min, wind, gust);
        scales.wind.max = Math.max(scales.wind.max, wind, gust);

        // Visibility
        const vis = data.visibility[idx] || 0;
        scales.visibility.min = Math.min(scales.visibility.min, vis);
        scales.visibility.max = Math.max(scales.visibility.max, vis);

        // Precipitation (snowfall and rain totals)
        const snow = data.snowfall[idx] || 0;
        const rain = data.rain[idx] || 0;
        scales.precip.max = Math.max(scales.precip.max, snow, rain);
      });
    });

    // Add padding to scales (10%)
    scales.temp.min = Math.floor(scales.temp.min * 1.1);
    scales.temp.max = Math.ceil(scales.temp.max * 1.1);
    scales.wind.min = 0; // Wind always starts at 0
    scales.wind.max = Math.ceil(scales.wind.max * 1.1);
    scales.visibility.min = 0; // Visibility always starts at 0
    scales.visibility.max = Math.ceil(scales.visibility.max * 1.1);
    scales.precip.max = Math.ceil(scales.precip.max * 1.1);

    return scales;
  }

  function createChart(config, dateStr, labels, hourlyIndices, scales) {
    const elevation = $('#elevation-select').val();
    const ctx = document.getElementById(config.id).getContext('2d');

    const colors = [
      { bg: 'rgba(239, 68, 68, 0.6)', border: 'rgba(239, 68, 68, 1)' },
      { bg: 'rgba(249, 115, 22, 0.6)', border: 'rgba(249, 115, 22, 1)' },
      { bg: 'rgba(34, 197, 94, 0.6)', border: 'rgba(34, 197, 94, 1)' },
      { bg: 'rgba(59, 130, 246, 0.6)', border: 'rgba(59, 130, 246, 1)' },
      { bg: 'rgba(168, 85, 247, 0.6)', border: 'rgba(168, 85, 247, 1)' },
      { bg: 'rgba(236, 72, 153, 0.6)', border: 'rgba(236, 72, 153, 1)' },
      { bg: 'rgba(14, 165, 233, 0.6)', border: 'rgba(14, 165, 233, 1)' }
    ];

    let datasets;
    let chartData;

    if (config.type === 'bar') {
      // For bar charts, create one dataset with all mountain totals
      const barData = mountains.map((mountain, idx) => {
        const data = weatherData[mountain.name][elevation].hourly;
        const values = hourlyIndices.map(i => data[config.dataKey][i]);
        return values.reduce((a, b) => a + b, 0);
      });

      const backgroundColors = mountains.map((m, idx) => colors[idx % colors.length].bg);
      const borderColors = mountains.map((m, idx) => colors[idx % colors.length].border);

      datasets = [{
        label: config.yAxisLabel,
        data: barData,
        backgroundColor: backgroundColors,
        borderColor: borderColors,
        borderWidth: 2
      }];

      chartData = {
        labels: mountains.map(m => m.name),
        datasets: datasets
      };
    } else {
      // For line charts, create one dataset per mountain
      datasets = mountains.map((mountain, idx) => {
        const data = weatherData[mountain.name][elevation].hourly;
        const values = hourlyIndices.map(i => data[config.dataKey][i]);
        const color = colors[idx % colors.length];

        return {
          label: mountain.name,
          data: values,
          backgroundColor: color.bg,
          borderColor: color.border,
          borderWidth: 2,
          fill: false,
          tension: 0.4,
          hidden: activeSeries !== null && activeSeries !== mountain.name
        };
      });

      chartData = {
        labels: labels,
        datasets: datasets
      };
    }

    const skiDayStart = config.type === 'bar' ? null : labels.indexOf('9:00');
    const skiDayEnd = config.type === 'bar' ? null : labels.indexOf('16:00');

    // Build annotations
    const annotations = {};

    // Add ski day shaded area for line charts
    if (config.type === 'line' && skiDayStart !== -1) {
      annotations.skiDay = {
        type: 'box',
        xMin: skiDayStart,
        xMax: skiDayEnd,
        backgroundColor: 'rgba(255, 215, 0, 0.1)',
        borderColor: 'rgba(255, 215, 0, 0.3)',
        borderWidth: 1
      };
    }

    // Add threshold lines for temperature and wind charts
    if (config.yAxisLabel === '¬∞F') {
      annotations.tempYellowLine = {
        type: 'line',
        yMin: 0,
        yMax: 0,
        borderColor: 'rgba(234, 179, 8, 0.8)',
        borderWidth: 2,
        borderDash: [6, 6],
        label: {
          display: true,
          content: '0¬∞F Warning',
          position: 'start',
          backgroundColor: 'rgba(234, 179, 8, 0.8)',
          color: 'white',
          font: {
            size: 10
          }
        }
      };
      annotations.tempRedLine = {
        type: 'line',
        yMin: -10,
        yMax: -10,
        borderColor: 'rgba(239, 68, 68, 0.8)',
        borderWidth: 2,
        borderDash: [6, 6],
        label: {
          display: true,
          content: '-10¬∞F Avoid',
          position: 'end',
          backgroundColor: 'rgba(239, 68, 68, 0.8)',
          color: 'white',
          font: {
            size: 10
          }
        }
      };
    }

    if (config.yAxisLabel === 'mph') {
      annotations.windYellowLine = {
        type: 'line',
        yMin: 30,
        yMax: 30,
        borderColor: 'rgba(234, 179, 8, 0.8)',
        borderWidth: 2,
        borderDash: [6, 6],
        label: {
          display: true,
          content: '30mph Warning',
          position: 'start',
          backgroundColor: 'rgba(234, 179, 8, 0.8)',
          color: 'white',
          font: {
            size: 10
          }
        }
      };
      annotations.windRedLine = {
        type: 'line',
        yMin: 40,
        yMax: 40,
        borderColor: 'rgba(239, 68, 68, 0.8)',
        borderWidth: 2,
        borderDash: [6, 6],
        label: {
          display: true,
          content: '40mph Avoid',
          position: 'end',
          backgroundColor: 'rgba(239, 68, 68, 0.8)',
          color: 'white',
          font: {
            size: 10
          }
        }
      };
    }

    const chartOptions = {
      responsive: true,
      maintainAspectRatio: true,
      aspectRatio: config.type === 'bar' ? 1.5 : 4/3.6,
      onClick: (e, elements) => {
        if (config.type === 'line' && elements.length > 0) {
          const datasetIndex = elements[0].datasetIndex;
          const clickedMountain = mountains[datasetIndex].name;
          toggleSeriesSolo(clickedMountain);
        }
      },
      plugins: {
        legend: {
          display: config.type === 'line',
          position: 'top',
          onClick: (e, legendItem, legend) => {
            if (config.type === 'line') {
              const index = legendItem.datasetIndex;
              const clickedMountain = mountains[index].name;
              toggleSeriesSolo(clickedMountain);
            }
          }
        },
        tooltip: {
          mode: 'index',
          intersect: false
        },
        annotation: {
          annotations: annotations
        }
      },
      scales: {
        y: {
          beginAtZero: config.type === 'bar' ? true : false,
          min: getYAxisMin(config, scales),
          max: getYAxisMax(config, scales),
          title: {
            display: true,
            text: config.yAxisLabel
          }
        },
        x: {
          title: {
            display: config.type === 'line',
            text: 'Time'
          },
          ticks: {
            autoSkip: config.type === 'line' ? true : false,
            maxRotation: config.type === 'bar' ? 45 : 0,
            minRotation: config.type === 'bar' ? 45 : 0
          }
        }
      }
    };

    // Add bar-specific options
    if (config.type === 'bar') {
      chartOptions.barPercentage = 0.8;
      chartOptions.categoryPercentage = 0.9;
    }

    const chart = new Chart(ctx, {
      type: config.type,
      data: chartData,
      options: chartOptions
    });

    charts[config.id] = chart;
  }

  function toggleSeriesSolo(mountainName) {
    if (activeSeries === mountainName) {
      // Un-solo - show all
      activeSeries = null;
    } else {
      // Solo this mountain
      activeSeries = mountainName;
    }

    // Update all charts
    Object.values(charts).forEach(chart => {
      chart.data.datasets.forEach((dataset, idx) => {
        const datasetMountain = mountains[idx].name;
        dataset.hidden = activeSeries !== null && activeSeries !== datasetMountain;
      });
      chart.update();
    });
  }

  // Carousel Navigation Functions
  function navigateCarousel(direction) {
    const newIndex = currentDayIndex + direction;
    if (newIndex >= 0 && newIndex < totalDays) {
      goToDay(newIndex);
    }
  }

  function goToDay(index) {
    currentDayIndex = index;
    // Calculate offset as percentage of track width
    // Each day takes up (100 / totalDays)% of the track
    const offset = -(100 / totalDays) * index;
    $('.carousel-track').css('transform', `translateX(${offset}%)`);

    // Update indicators
    $('.carousel-indicator').removeClass('active');
    $(`.carousel-indicator[data-index="${index}"]`).addClass('active');

    updateCarouselNav();

    // Resize charts on the current day after transition
    setTimeout(() => {
      Object.values(charts).forEach(chart => {
        if (chart && chart.resize) {
          chart.resize();
        }
      });
    }, 350); // Wait for transition to complete (300ms + buffer)
  }

  function updateCarouselNav() {
    // Disable/enable navigation buttons
    $('#carousel-prev').prop('disabled', currentDayIndex === 0);
    $('#carousel-next').prop('disabled', currentDayIndex === totalDays - 1);
  }

  // Touch/Swipe Support
  function setupTouchSupport() {
    let touchStartX = 0;
    let touchEndX = 0;

    $('.carousel-container').off('touchstart touchend').on('touchstart', function(e) {
      touchStartX = e.changedTouches[0].screenX;
    }).on('touchend', function(e) {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe();
    });

    function handleSwipe() {
      const swipeThreshold = 50;
      if (touchEndX < touchStartX - swipeThreshold) {
        // Swipe left - go to next day
        navigateCarousel(1);
      } else if (touchEndX > touchStartX + swipeThreshold) {
        // Swipe right - go to previous day
        navigateCarousel(-1);
      }
    }
  }

  function updateElevationDisplay() {
    // Re-render comparison tables and charts with new elevation
    const startDate = $('#start-date').val();
    const endDate = $('#end-date').val();

    if (startDate && endDate && Object.keys(weatherData).length > 0) {
      renderResults(startDate, endDate);
    }
  }

  function toggleMountainManager() {
    $('#mountain-manager').slideToggle(300);
  }

  function showError(message) {
    $('#error-message').text(message);
    $('#error-modal').show();
  }

  // Make functions globally accessible
  window.deleteMountain = deleteMountain;
  window.editMountain = editMountain;
  window.saveMountainEdit = saveMountainEdit;
  window.cancelMountainEdit = cancelMountainEdit;
</script>
</body>
</html>

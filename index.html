<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚õ∑Ô∏è Ski Mountain Forecast Analyzer</title>

  <!-- Dependencies -->
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>

  <style>
    * {
      box-sizing: border-box;
    }

    * {
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      margin: 0;
      padding: 0;
      background: #f0f4f8;
      padding-bottom: 50px;
    }

    .container {
      max-width: 98%;
      margin: 0 auto;
      padding: 0 10px;
    }

    /* Top Form - Sticky */
    #top-form {
      position: sticky;
      top: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    #top-form h1 {
      margin: 0 0 15px 0;
      font-size: 24px;
    }

    .form-row {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .form-group label {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .form-group input,
    .form-group select,
    .form-group button {
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
    }

    .btn {
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }

    .btn-primary {
      background: #10b981;
      color: white;
    }

    .btn-primary:hover {
      background: #059669;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .btn-secondary {
      background: #3b82f6;
      color: white;
    }

    .btn-secondary:hover {
      background: #2563eb;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    /* Progress Bar */
    #progress-container {
      display: none;
      margin-top: 10px;
      background: rgba(255,255,255,0.3);
      border-radius: 10px;
      overflow: hidden;
      position: relative;
      height: 30px;
    }

    #progress-bar {
      height: 30px;
      background: #10b981;
      width: 0%;
      transition: width 0.3s;
    }

    #progress-text {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      pointer-events: none;
    }

    /* Mountain Manager */
    #mountain-manager {
      background: white;
      padding: 25px;
      margin: 20px auto;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    #mountain-manager h2 {
      margin-top: 0;
      color: #1f2937;
    }

    .mountain-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .mountain-table th,
    .mountain-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }

    .mountain-table th {
      background: #f9fafb;
      font-weight: 600;
      color: #374151;
    }

    .mountain-table tr:hover {
      background: #f9fafb;
    }

    .mountain-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin: 20px 0;
      padding: 20px;
      background: #f9fafb;
      border-radius: 8px;
    }

    .mountain-form input {
      padding: 8px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
    }

    /* Results Section */
    #results {
      margin-top: 20px;
    }

    .winner-box {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      color: #78350f;
      padding: 25px;
      margin: 20px auto;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .winner-box h2 {
      margin-top: 0;
      font-size: 28px;
    }

    .pros-cons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 15px;
    }

    .pros-cons h3 {
      margin-top: 0;
    }

    .pros-cons ul {
      margin: 10px 0;
      padding-left: 20px;
    }

    .pros-cons li {
      margin: 8px 0;
    }

    /* Day Box */
    .day-box {
      background: transparent;
      margin: 20px auto;
    }

    .day-header {
      position: -webkit-sticky;
      position: sticky;
      top: 90px;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      padding: 15px 25px;
      z-index: 500;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 16px;
      font-weight: 600;
      white-space: nowrap;
      border-radius: 12px 12px 0 0;
      margin-bottom: 0;
    }

    .day-content {
      background: white;
      border-radius: 0 0 12px 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .comparison-table-wrapper {
      position: relative;
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }

    .comparison-table th {
      background: #1f2937;
      color: white;
      padding: 12px 8px;
      text-align: left;
      font-size: 12px;
      border-right: 1px solid #374151;
    }

    .comparison-table th:first-child,
    .comparison-table td:first-child {
      width: 20%;
      min-width: 180px;
    }

    .comparison-table td {
      padding: 12px 8px;
      border-bottom: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
    }

    .comparison-table tr:hover {
      background: #f9fafb;
    }

    .score {
      font-weight: 700;
      font-size: 18px;
      color: #10b981;
    }

    .charts-container {
      padding: 25px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      border-radius: 0 0 12px 12px;
    }

    .chart-wrapper {
      background: #f9fafb;
      padding: 15px;
      border-radius: 8px;
      position: relative;
    }

    .chart-wrapper canvas {
      max-height: 480px;
    }

    .chart-title {
      font-weight: 600;
      margin-bottom: 10px;
      color: #1f2937;
    }

    /* Modal for errors */
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    .modal-content {
      background-color: white;
      margin: 15% auto;
      padding: 30px;
      border-radius: 12px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover {
      color: #000;
    }

    /* Small buttons */
    .btn-sm {
      padding: 5px 10px;
      font-size: 12px;
    }

    /* Utility */
    .text-center {
      text-align: center;
    }

    .mt-2 {
      margin-top: 20px;
    }
  </style>
</head>
<body>
<!-- Top Form -->
<div id="top-form">
  <div class="container">
    <h1>‚õ∑Ô∏è Ski Mountain Forecast Analyzer</h1>
    <div class="form-row">
      <div class="form-group">
        <label>üìÖ Start Date</label>
        <input type="text" id="start-date" readonly>
      </div>
      <div class="form-group">
        <label>üìÖ End Date</label>
        <input type="text" id="end-date" readonly>
      </div>
      <div class="form-group">
        <label>&nbsp;</label>
        <button class="btn btn-secondary" id="this-weekend">This Weekend</button>
      </div>
      <div class="form-group">
        <label>&nbsp;</label>
        <button class="btn btn-secondary" id="next-weekend">Next Weekend</button>
      </div>
      <div class="form-group">
        <label>üèîÔ∏è Elevation</label>
        <select id="elevation-select">
          <option value="base">Base</option>
          <option value="mid" selected>Mid-Mountain</option>
          <option value="peak">Peak</option>
        </select>
      </div>
      <div class="form-group">
        <label>&nbsp;</label>
        <button class="btn btn-primary" id="load-forecast">üîÆ Load Forecast</button>
      </div>
    </div>
    <div id="progress-container">
      <div id="progress-bar"></div>
      <div id="progress-text">0%</div>
    </div>
  </div>
</div>

<!-- Mountain Manager -->
<div class="container">
  <div id="mountain-manager">
    <h2>üèîÔ∏è Mountain Manager</h2>

    <div class="mountain-form">
      <input type="text" id="new-name" placeholder="Mountain Name">
      <input type="number" step="0.0001" id="new-lat" placeholder="Latitude">
      <input type="number" step="0.0001" id="new-lng" placeholder="Longitude">
      <input type="number" id="new-base" placeholder="Base Elevation (ft)">
      <input type="number" id="new-peak" placeholder="Peak Elevation (ft)">
      <button class="btn btn-primary" id="add-mountain">‚ûï Add Mountain</button>
    </div>

    <button class="btn btn-secondary mt-2" id="add-epic-northeast">‚≠ê Add All Epic Northeast Mountains</button>

    <div style="overflow-x: auto;">
      <table class="mountain-table">
        <thead>
        <tr>
          <th>Mountain Name</th>
          <th>Latitude</th>
          <th>Longitude</th>
          <th>Base (ft)</th>
          <th>Peak (ft)</th>
          <th>Mid (ft)</th>
          <th>Actions</th>
        </tr>
        </thead>
        <tbody id="mountains-tbody">
        </tbody>
      </table>
    </div>
  </div>

  <!-- Results -->
  <div id="results"></div>
</div>

<!-- Error Modal -->
<div id="error-modal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>‚ùå Error</h2>
    <p id="error-message"></p>
  </div>
</div>

<script>
  // Global state
  let mountains = [];
  let weatherData = {};
  let charts = {};
  let activeSeries = null;
  let editingIndex = null;

  // Epic Northeast Mountains Data
  const EPIC_NORTHEAST_MOUNTAINS = [
    { name: 'Stowe Mountain Resort', lat: 44.5304, lng: -72.7875, base: 1600, peak: 3625 },
    { name: 'Okemo Mountain Resort', lat: 43.4018, lng: -72.7159, base: 1194, peak: 3343 },
    { name: 'Mount Snow', lat: 42.9604, lng: -72.9201, base: 1900, peak: 3600 },
    { name: 'Wildcat Mountain', lat: 44.2626, lng: -71.2321, base: 1974, peak: 4062 },
    { name: 'Attitash Mountain Resort', lat: 44.0854, lng: -71.2511, base: 950, peak: 2350 },
    { name: 'Mount Sunapee Resort', lat: 43.3359, lng: -72.0833, base: 1035, peak: 2743 },
    { name: 'Crotched Mountain', lat: 43.0127, lng: -71.8715, base: 1155, peak: 2066 }
  ];

  // Initialize
  $(document).ready(function() {
    initializeDatePickers();
    loadMountains();
    renderMountainsTable();
    setThisWeekend();

    // Event listeners
    $('#this-weekend').click(setThisWeekend);
    $('#next-weekend').click(setNextWeekend);
    $('#add-mountain').click(addMountain);
    $('#add-epic-northeast').click(addEpicNortheastMountains);
    $('#load-forecast').click(loadForecast);
    $('#elevation-select').change(updateElevationDisplay);
    $('.close').click(() => $('#error-modal').hide());
  });

  // Date picker initialization
  function initializeDatePickers() {
    $('#start-date, #end-date').datepicker({
      dateFormat: 'yy-mm-dd',
      minDate: 0
    });
  }

  // Weekend functions
  function setThisWeekend() {
    const today = new Date();
    const dayOfWeek = today.getDay();
    const daysUntilFriday = (5 - dayOfWeek + 7) % 7;
    const friday = new Date(today);
    friday.setDate(today.getDate() + daysUntilFriday);

    const sunday = new Date(friday);
    sunday.setDate(friday.getDate() + 2);

    $('#start-date').val(formatDate(friday));
    $('#end-date').val(formatDate(sunday));
  }

  function setNextWeekend() {
    const today = new Date();
    const dayOfWeek = today.getDay();
    const daysUntilFriday = ((5 - dayOfWeek + 7) % 7) + 7;
    const friday = new Date(today);
    friday.setDate(today.getDate() + daysUntilFriday);

    const sunday = new Date(friday);
    sunday.setDate(friday.getDate() + 2);

    $('#start-date').val(formatDate(friday));
    $('#end-date').val(formatDate(sunday));
  }

  function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // Mountain management
  function loadMountains() {
    const stored = localStorage.getItem('mountains');
    if (stored) {
      mountains = JSON.parse(stored);
    }
  }

  function saveMountains() {
    localStorage.setItem('mountains', JSON.stringify(mountains));
  }

  function addMountain() {
    const name = $('#new-name').val().trim();
    const lat = parseFloat($('#new-lat').val());
    const lng = parseFloat($('#new-lng').val());
    const base = parseInt($('#new-base').val());
    const peak = parseInt($('#new-peak').val());

    if (!name || isNaN(lat) || isNaN(lng) || isNaN(base) || isNaN(peak)) {
      showError('Please fill in all mountain fields with valid values');
      return;
    }

    mountains.push({ name, lat, lng, base, peak });
    saveMountains();
    renderMountainsTable();

    // Clear form
    $('#new-name, #new-lat, #new-lng, #new-base, #new-peak').val('');
  }

  function addEpicNortheastMountains() {
    mountains = [...EPIC_NORTHEAST_MOUNTAINS];
    saveMountains();
    renderMountainsTable();
  }

  function deleteMountain(index) {
    if (confirm(`Delete ${mountains[index].name}?`)) {
      mountains.splice(index, 1);
      saveMountains();
      renderMountainsTable();
    }
  }

  function editMountain(index) {
    editingIndex = index;
    renderMountainsTable();
  }

  function saveMountainEdit(index) {
    const name = $(`#edit-name-${index}`).val().trim();
    const lat = parseFloat($(`#edit-lat-${index}`).val());
    const lng = parseFloat($(`#edit-lng-${index}`).val());
    const base = parseInt($(`#edit-base-${index}`).val());
    const peak = parseInt($(`#edit-peak-${index}`).val());

    if (!name || isNaN(lat) || isNaN(lng) || isNaN(base) || isNaN(peak)) {
      showError('Please fill in all fields with valid values');
      return;
    }

    mountains[index] = { name, lat, lng, base, peak };
    saveMountains();
    editingIndex = null;
    renderMountainsTable();
  }

  function cancelMountainEdit() {
    editingIndex = null;
    renderMountainsTable();
  }

  function renderMountainsTable() {
    const tbody = $('#mountains-tbody');
    tbody.empty();

    mountains.forEach((m, idx) => {
      const mid = Math.round((m.peak + m.base) / 2);

      if (editingIndex === idx) {
        // Render editable row
        const row = $(`
                    <tr style="background: #fef3c7;">
                        <td><input type="text" id="edit-name-${idx}" value="${m.name}" style="width: 100%; padding: 4px;"></td>
                        <td><input type="number" step="0.0001" id="edit-lat-${idx}" value="${m.lat}" style="width: 100%; padding: 4px;"></td>
                        <td><input type="number" step="0.0001" id="edit-lng-${idx}" value="${m.lng}" style="width: 100%; padding: 4px;"></td>
                        <td><input type="number" id="edit-base-${idx}" value="${m.base}" style="width: 100%; padding: 4px;"></td>
                        <td><input type="number" id="edit-peak-${idx}" value="${m.peak}" style="width: 100%; padding: 4px;"></td>
                        <td>${mid}</td>
                        <td>
                            <button class="btn btn-primary btn-sm" onclick="saveMountainEdit(${idx})">üíæ Save</button>
                            <button class="btn btn-secondary btn-sm" onclick="cancelMountainEdit()">‚ùå Cancel</button>
                        </td>
                    </tr>
                `);
        tbody.append(row);
      } else {
        // Render normal row
        const row = $(`
                    <tr>
                        <td>${m.name}</td>
                        <td>${m.lat.toFixed(4)}</td>
                        <td>${m.lng.toFixed(4)}</td>
                        <td>${m.base}</td>
                        <td>${m.peak}</td>
                        <td>${mid}</td>
                        <td>
                            <button class="btn btn-secondary btn-sm" onclick="editMountain(${idx})">‚úèÔ∏è Edit</button>
                            <button class="btn btn-danger btn-sm" onclick="deleteMountain(${idx})">üóëÔ∏è Delete</button>
                        </td>
                    </tr>
                `);
        tbody.append(row);
      }
    });
  }

  // Weather fetching
  async function loadForecast() {
    if (mountains.length === 0) {
      showError('Please add at least one mountain first');
      return;
    }

    const startDate = $('#start-date').val();
    const endDate = $('#end-date').val();

    if (!startDate || !endDate) {
      showError('Please select start and end dates');
      return;
    }

    // Calculate date range including 7 days prior for freeze-thaw analysis
    const start = new Date(startDate);
    const historicStart = new Date(start);
    historicStart.setDate(start.getDate() - 7);
    const historicStartStr = formatDate(historicStart);

    $('#progress-container').show();
    $('#progress-bar').css('width', '0%');
    $('#progress-text').text('0%');
    weatherData = {};

    try {
      for (let i = 0; i < mountains.length; i++) {
        const mountain = mountains[i];
        const progress = Math.round(((i + 1) / mountains.length) * 100);
        $('#progress-bar').css('width', progress + '%');
        $('#progress-text').text(`Loading ${mountain.name}... ${progress}%`);

        const data = await fetchWeatherForMountain(mountain, historicStartStr, endDate);
        weatherData[mountain.name] = data;
      }

      renderResults(startDate, endDate);
      $('#progress-container').hide();
    } catch (error) {
      $('#progress-container').hide();
      showError(`Failed to load forecast: ${error.message}`);
    }
  }

  async function fetchWeatherForMountain(mountain, startDate, endDate) {
    const mid = Math.round((mountain.peak + mountain.base) / 2);

    // Fetch data for all three elevations
    const elevations = {
      base: mountain.base,
      mid: mid,
      peak: mountain.peak
    };

    const results = {};

    for (const [key, elevation] of Object.entries(elevations)) {
      const url = buildOpenMeteoUrl(mountain.lat, mountain.lng, elevation, startDate, endDate);
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`Failed to fetch weather for ${mountain.name} at ${key} elevation: ${response.statusText}`);
      }

      const data = await response.json();
      results[key] = data;
    }

    return results;
  }

  function buildOpenMeteoUrl(lat, lng, elevation, startDate, endDate) {
    // Convert feet to meters (API expects meters)
    const elevationMeters = Math.round(elevation * 0.3048);
    const params = new URLSearchParams({
      latitude: lat,
      longitude: lng,
      elevation: elevationMeters,
      start_date: startDate,
      end_date: endDate,
      hourly: [
        'temperature_2m',
        'apparent_temperature',
        'precipitation',
        'rain',
        'snowfall',
        'weather_code',
        'cloud_cover',
        'visibility',
        'wind_speed_10m',
        'wind_direction_10m',
        'wind_gusts_10m'
      ].join(','),
      temperature_unit: 'fahrenheit',
      wind_speed_unit: 'mph',
      precipitation_unit: 'inch',
      timezone: 'America/New_York'
    });

    return `https://api.open-meteo.com/v1/forecast?${params}`;
  }

  // Results rendering
  function renderResults(startDate, endDate) {
    const results = $('#results');
    results.empty();

    // Destroy existing charts
    Object.values(charts).forEach(chart => chart.destroy());
    charts = {};

    // Calculate overall winner
    const overallWinner = calculateOverallWinner(startDate, endDate);
    renderOverallWinner(overallWinner);

    // Render each day - use date strings to avoid timezone issues
    const start = new Date(startDate + 'T12:00:00');
    const end = new Date(endDate + 'T12:00:00');
    const currentDate = new Date(start);

    while (currentDate <= end) {
      const dateStr = formatDate(currentDate);

      // Only render if this date is within our selected range
      if (dateStr >= startDate && dateStr <= endDate) {
        renderDayBox(dateStr, new Date(currentDate));
      }

      currentDate.setDate(currentDate.getDate() + 1);
    }
  }

  function calculateOverallWinner(startDate, endDate) {
    const scores = {};
    const reasonings = {};

    mountains.forEach(mountain => {
      let totalScore = 0;
      let count = 0;
      const pros = [];
      const cons = [];

      const start = new Date(startDate);
      const end = new Date(endDate);

      for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
        const dateStr = formatDate(d);
        const dayScore = calculateDayScore(mountain, dateStr);
        totalScore += dayScore.score;
        count++;
      }

      const avgScore = totalScore / count;
      scores[mountain.name] = avgScore;

      // Analyze overall conditions
      const elevation = $('#elevation-select').val();
      const data = weatherData[mountain.name][elevation].hourly;

      // Calculate aggregate metrics
      let totalSnow = 0;
      let totalRain = 0;
      let avgTemp = 0;
      let maxWind = 0;
      let avgVisibility = 0;
      let tempCount = 0;

      data.time.forEach((time, idx) => {
        const date = time.split('T')[0];
        if (date >= startDate && date <= endDate) {
          const hour = parseInt(time.split('T')[1].split(':')[0]);
          if (hour >= 9 && hour <= 16) {
            totalSnow += data.snowfall[idx] || 0;
            totalRain += data.rain[idx] || 0;
            avgTemp += data.temperature_2m[idx] || 0;
            maxWind = Math.max(maxWind, data.wind_speed_10m[idx] || 0);
            avgVisibility += data.visibility[idx] || 0;
            tempCount++;
          }
        }
      });

      avgTemp /= tempCount;
      avgVisibility /= tempCount;

      // Determine pros
      if (totalSnow > 3) pros.push(`üå®Ô∏è Excellent snowfall: ${totalSnow.toFixed(1)}" expected`);
      else if (totalSnow > 1) pros.push(`‚ùÑÔ∏è Good snowfall: ${totalSnow.toFixed(1)}" expected`);

      if (avgTemp >= 20 && avgTemp <= 32) pros.push(`üå°Ô∏è Perfect skiing temps: ${avgTemp.toFixed(0)}¬∞F average`);
      else if (avgTemp > 32 && avgTemp <= 40) pros.push(`‚òÄÔ∏è Mild temperatures: ${avgTemp.toFixed(0)}¬∞F average`);

      if (maxWind < 15) pros.push(`üí® Low wind speeds: max ${maxWind.toFixed(0)} mph`);
      else if (maxWind < 25) pros.push(`üçÉ Moderate winds: max ${maxWind.toFixed(0)} mph`);

      if (avgVisibility > 15000) pros.push(`üëÅÔ∏è Excellent visibility: ${(avgVisibility/5280).toFixed(1)} miles`);

      // Determine cons
      if (totalSnow < 0.5 && totalRain < 0.5) cons.push(`üèúÔ∏è Limited precipitation: ${(totalSnow + totalRain).toFixed(1)}" total`);

      if (totalRain > 0.5) cons.push(`üåßÔ∏è Rain expected: ${totalRain.toFixed(1)}"`);

      if (avgTemp < 10) cons.push(`ü•∂ Very cold temps: ${avgTemp.toFixed(0)}¬∞F average`);
      else if (avgTemp > 40) cons.push(`üî• Warm temps may soften snow: ${avgTemp.toFixed(0)}¬∞F average`);

      if (maxWind > 25) cons.push(`üí® High winds: gusts up to ${maxWind.toFixed(0)} mph`);
      else if (maxWind > 35) cons.push(`‚ö†Ô∏è Very high winds: gusts up to ${maxWind.toFixed(0)} mph`);

      if (avgVisibility < 5000) cons.push(`üå´Ô∏è Poor visibility: ${(avgVisibility/5280).toFixed(1)} miles`);

      reasonings[mountain.name] = { pros, cons };
    });

    // Find winner
    let winner = null;
    let maxScore = -1;

    for (const [name, score] of Object.entries(scores)) {
      if (score > maxScore) {
        maxScore = score;
        winner = name;
      }
    }

    return {
      name: winner,
      score: maxScore,
      pros: reasonings[winner].pros,
      cons: reasonings[winner].cons
    };
  }

  function renderOverallWinner(winner) {
    const html = $(`
                <div class="winner-box">
                    <h2>üèÜ Overall Winner: ${winner.name}</h2>
                    <p><strong>Overall Score:</strong> ${winner.score.toFixed(1)}/100</p>
                    <div class="pros-cons">
                        <div>
                            <h3>‚úÖ Pros</h3>
                            <ul>
                                ${winner.pros.map(p => `<li>${p}</li>`).join('')}
                            </ul>
                        </div>
                        <div>
                            <h3>‚ö†Ô∏è Cons</h3>
                            <ul>
                                ${winner.cons.length > 0 ? winner.cons.map(c => `<li>${c}</li>`).join('') : '<li>No significant drawbacks!</li>'}
                            </ul>
                        </div>
                    </div>
                </div>
            `);

    $('#results').append(html);
  }

  function renderDayBox(dateStr, dateObj) {
    const dayName = dateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });

    // Calculate day winner
    const dayWinner = calculateDayWinner(dateStr);

    const boxId = `day-${dateStr}`;
    const box = $(`
                <div class="day-box" id="${boxId}">
                    <div class="day-header">
                        üìÜ ${dayName} &nbsp;&nbsp;&nbsp; ü•á Winner: ${dayWinner.name} (Score: ${dayWinner.score.toFixed(1)}/100) &nbsp;&nbsp;&nbsp; Why it won: ${dayWinner.reason}
                    </div>
                    <div class="day-content">
                        <div class="comparison-table-wrapper">
                            <table class="comparison-table" id="table-${dateStr}">
                            </table>
                        </div>
                        <div class="charts-container" id="charts-${dateStr}">
                        </div>
                    </div>
                </div>
            `);

    $('#results').append(box);
    renderComparisonTable(dateStr);
    renderCharts(dateStr);
  }

  function calculateDayWinner(dateStr) {
    const scores = {};
    const reasons = {};

    mountains.forEach(mountain => {
      const result = calculateDayScore(mountain, dateStr);
      scores[mountain.name] = result.score;
      reasons[mountain.name] = result.reason;
    });

    let winner = null;
    let maxScore = -1;

    for (const [name, score] of Object.entries(scores)) {
      if (score > maxScore) {
        maxScore = score;
        winner = name;
      }
    }

    return {
      name: winner,
      score: maxScore,
      reason: reasons[winner]
    };
  }

  function calculateDayScore(mountain, dateStr) {
    const elevation = $('#elevation-select').val();
    const data = weatherData[mountain.name][elevation].hourly;

    // Extract ski hours (9am-4pm) for this date
    const skiData = {
      temps: [],
      apparentTemps: [],
      winds: [],
      gusts: [],
      snowfall: 0,
      rain: 0,
      visibility: []
    };

    data.time.forEach((time, idx) => {
      if (time.startsWith(dateStr)) {
        const hour = parseInt(time.split('T')[1].split(':')[0]);
        if (hour >= 9 && hour <= 16) {
          skiData.temps.push(data.temperature_2m[idx] || 0);
          skiData.apparentTemps.push(data.apparent_temperature[idx] || 0);
          skiData.winds.push(data.wind_speed_10m[idx] || 0);
          skiData.gusts.push(data.wind_gusts_10m[idx] || 0);
          skiData.snowfall += data.snowfall[idx] || 0;
          skiData.rain += data.rain[idx] || 0;
          skiData.visibility.push(data.visibility[idx] || 0);
        }
      }
    });

    let score = 50; // Base score
    const reasons = [];

    // Temperature scoring (ideal: 20-32¬∞F)
    const avgTemp = skiData.temps.reduce((a, b) => a + b, 0) / skiData.temps.length;
    if (avgTemp >= 20 && avgTemp <= 32) {
      score += 15;
      reasons.push('ideal temps');
    } else if (avgTemp > 32 && avgTemp <= 40) {
      score += 10;
    } else if (avgTemp < 10) {
      score -= 15;
      reasons.push('very cold');
    } else if (avgTemp > 40) {
      score -= 10;
    }

    // Snowfall scoring
    if (skiData.snowfall > 3) {
      score += 20;
      reasons.push(`${skiData.snowfall.toFixed(1)}" snow`);
    } else if (skiData.snowfall > 1) {
      score += 15;
      reasons.push(`${skiData.snowfall.toFixed(1)}" snow`);
    } else if (skiData.snowfall > 0.5) {
      score += 10;
    }

    // Rain penalty
    if (skiData.rain > 0.5) {
      score -= 20;
      reasons.push('rain expected');
    } else if (skiData.rain > 0.1) {
      score -= 10;
    }

    // Wind scoring (low is good)
    const maxWind = Math.max(...skiData.winds);
    if (maxWind < 10) {
      score += 10;
      reasons.push('calm winds');
    } else if (maxWind > 25) {
      score -= 15;
      reasons.push('high winds');
    } else if (maxWind > 35) {
      score -= 25;
    }

    // Visibility scoring
    const avgVisibility = skiData.visibility.reduce((a, b) => a + b, 0) / skiData.visibility.length;
    if (avgVisibility > 15000) {
      score += 5;
      reasons.push('great visibility');
    } else if (avgVisibility < 5000) {
      score -= 10;
    }

    // Clamp score to 0-100
    score = Math.max(0, Math.min(100, score));

    return {
      score,
      reason: reasons.length > 0 ? reasons.join(', ') : 'moderate conditions'
    };
  }

  function renderComparisonTable(dateStr) {
    const elevation = $('#elevation-select').val();
    const table = $(`#table-${dateStr}`);

    // Build header
    const header = $(`
                <thead>
                    <tr>
                        <th>Mountain</th>
                        <th>Feels Like (¬∞F)</th>
                        <th>Temp (¬∞F)</th>
                        <th>Wind Speed (mph)</th>
                        <th>Max Gust (mph)</th>
                        <th>Wind Dir</th>
                        <th>Snow (in)</th>
                        <th>Rain (in)</th>
                        <th>Freeze-Thaw Cycles (7d)</th>
                    </tr>
                </thead>
            `);
    table.append(header);

    const tbody = $('<tbody></tbody>');

    mountains.forEach(mountain => {
      const data = weatherData[mountain.name][elevation].hourly;
      const metrics = calculateDayMetrics(data, dateStr);
      const score = calculateDayScore(mountain, dateStr).score;
      const freezeThaw = calculateFreezeThawCycles(mountain);

      const row = $(`
                    <tr>
                        <td><strong>${mountain.name}</strong></td>
                        <td>${metrics.feelsLikeMin.toFixed(0)} / ${metrics.feelsLikeMax.toFixed(0)}</td>
                        <td>${metrics.tempMin.toFixed(0)} / ${metrics.tempMax.toFixed(0)}</td>
                        <td>${metrics.windMin.toFixed(0)} / ${metrics.windMax.toFixed(0)}</td>
                        <td>${metrics.maxGust.toFixed(0)}</td>
                        <td>${metrics.windDir}</td>
                        <td>${metrics.snow.toFixed(2)}</td>
                        <td>${metrics.rain.toFixed(2)}</td>
                        <td>${freezeThaw}</td>
                    </tr>
                `);
      tbody.append(row);
    });

    table.append(tbody);
  }

  function calculateDayMetrics(data, dateStr) {
    let feelsLikeMin = Infinity, feelsLikeMax = -Infinity;
    let tempMin = Infinity, tempMax = -Infinity;
    let windMin = Infinity, windMax = -Infinity;
    let maxGust = 0;
    let snow = 0, rain = 0;
    const windDirs = [];

    data.time.forEach((time, idx) => {
      if (time.startsWith(dateStr)) {
        const hour = parseInt(time.split('T')[1].split(':')[0]);
        if (hour >= 9 && hour <= 16) {
          feelsLikeMin = Math.min(feelsLikeMin, data.apparent_temperature[idx] || 0);
          feelsLikeMax = Math.max(feelsLikeMax, data.apparent_temperature[idx] || 0);
          tempMin = Math.min(tempMin, data.temperature_2m[idx] || 0);
          tempMax = Math.max(tempMax, data.temperature_2m[idx] || 0);
          windMin = Math.min(windMin, data.wind_speed_10m[idx] || 0);
          windMax = Math.max(windMax, data.wind_speed_10m[idx] || 0);
          maxGust = Math.max(maxGust, data.wind_gusts_10m[idx] || 0);
          snow += data.snowfall[idx] || 0;
          rain += data.rain[idx] || 0;
          windDirs.push(data.wind_direction_10m[idx]);
        }
      }
    });

    // Average wind direction
    const avgWindDir = windDirs.reduce((a, b) => a + b, 0) / windDirs.length;
    const windDir = degreesToCardinal(avgWindDir);

    return {
      feelsLikeMin, feelsLikeMax,
      tempMin, tempMax,
      windMin, windMax,
      maxGust, snow, rain,
      windDir
    };
  }

  function calculateFreezeThawCycles(mountain) {
    const elevation = $('#elevation-select').val();
    const data = weatherData[mountain.name][elevation].hourly;

    let cycles = 0;
    let wasFrozen = null;

    data.temperature_2m.forEach(temp => {
      if (temp !== null) {
        const isFrozen = temp <= 32;
        if (wasFrozen !== null && wasFrozen !== isFrozen) {
          if (!isFrozen) { // Thawed
            // Wait for it to freeze again to count as a cycle
          } else if (wasFrozen === false) { // Was thawed, now frozen
            cycles++;
          }
        }
        wasFrozen = isFrozen;
      }
    });

    return cycles;
  }

  function degreesToCardinal(degrees) {
    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const index = Math.round(degrees / 45) % 8;
    return directions[index];
  }

  function renderCharts(dateStr) {
    const container = $(`#charts-${dateStr}`);
    const elevation = $('#elevation-select').val();

    // Prepare time labels for this day (ski hours only)
    const sampleData = weatherData[mountains[0].name][elevation].hourly;
    const labels = [];
    const hourlyIndices = [];

    sampleData.time.forEach((time, idx) => {
      if (time.startsWith(dateStr)) {
        const timePart = time.split('T')[1];
        const hour = parseInt(timePart.split(':')[0]);
        labels.push(`${hour}:00`);
        hourlyIndices.push(idx);
      }
    });

    // Chart configurations
    const chartConfigs = [
      {
        id: `chart-feels-like-${dateStr}`,
        title: 'üå°Ô∏è Feels Like Temperature',
        type: 'line',
        dataKey: 'apparent_temperature',
        yAxisLabel: '¬∞F',
        backgroundColor: 'rgba(239, 68, 68, 0.2)',
        borderColor: 'rgba(239, 68, 68, 1)'
      },
      {
        id: `chart-temp-${dateStr}`,
        title: 'üå°Ô∏è Actual Temperature',
        type: 'line',
        dataKey: 'temperature_2m',
        yAxisLabel: '¬∞F',
        backgroundColor: 'rgba(249, 115, 22, 0.2)',
        borderColor: 'rgba(249, 115, 22, 1)'
      },
      {
        id: `chart-wind-${dateStr}`,
        title: 'üí® Wind Speed',
        type: 'line',
        dataKey: 'wind_speed_10m',
        yAxisLabel: 'mph',
        backgroundColor: 'rgba(59, 130, 246, 0.2)',
        borderColor: 'rgba(59, 130, 246, 1)'
      },
      {
        id: `chart-gusts-${dateStr}`,
        title: 'üí® Wind Gusts',
        type: 'line',
        dataKey: 'wind_gusts_10m',
        yAxisLabel: 'mph',
        backgroundColor: 'rgba(99, 102, 241, 0.2)',
        borderColor: 'rgba(99, 102, 241, 1)'
      },
      {
        id: `chart-cloud-${dateStr}`,
        title: '‚òÅÔ∏è Cloud Cover',
        type: 'line',
        dataKey: 'cloud_cover',
        yAxisLabel: '%',
        backgroundColor: 'rgba(156, 163, 175, 0.2)',
        borderColor: 'rgba(156, 163, 175, 1)'
      },
      {
        id: `chart-visibility-${dateStr}`,
        title: 'üëÅÔ∏è Visibility',
        type: 'line',
        dataKey: 'visibility',
        yAxisLabel: 'feet',
        backgroundColor: 'rgba(168, 85, 247, 0.2)',
        borderColor: 'rgba(168, 85, 247, 1)'
      },
      {
        id: `chart-snow-${dateStr}`,
        title: '‚ùÑÔ∏è Snowfall',
        type: 'bar',
        dataKey: 'snowfall',
        yAxisLabel: 'inches',
        backgroundColor: 'rgba(14, 165, 233, 0.6)',
        borderColor: 'rgba(14, 165, 233, 1)'
      },
      {
        id: `chart-rain-${dateStr}`,
        title: 'üåßÔ∏è Rainfall',
        type: 'bar',
        dataKey: 'rain',
        yAxisLabel: 'inches',
        backgroundColor: 'rgba(34, 197, 94, 0.6)',
        borderColor: 'rgba(34, 197, 94, 1)'
      }
    ];

    chartConfigs.forEach(config => {
      const wrapper = $(`
                    <div class="chart-wrapper">
                        <div class="chart-title">${config.title}</div>
                        <canvas id="${config.id}"></canvas>
                    </div>
                `);
      container.append(wrapper);

      createChart(config, dateStr, labels, hourlyIndices);
    });
  }

  function createChart(config, dateStr, labels, hourlyIndices) {
    const elevation = $('#elevation-select').val();
    const ctx = document.getElementById(config.id).getContext('2d');

    const colors = [
      { bg: 'rgba(239, 68, 68, 0.6)', border: 'rgba(239, 68, 68, 1)' },
      { bg: 'rgba(249, 115, 22, 0.6)', border: 'rgba(249, 115, 22, 1)' },
      { bg: 'rgba(34, 197, 94, 0.6)', border: 'rgba(34, 197, 94, 1)' },
      { bg: 'rgba(59, 130, 246, 0.6)', border: 'rgba(59, 130, 246, 1)' },
      { bg: 'rgba(168, 85, 247, 0.6)', border: 'rgba(168, 85, 247, 1)' },
      { bg: 'rgba(236, 72, 153, 0.6)', border: 'rgba(236, 72, 153, 1)' },
      { bg: 'rgba(14, 165, 233, 0.6)', border: 'rgba(14, 165, 233, 1)' }
    ];

    let datasets;
    let chartData;

    if (config.type === 'bar') {
      // For bar charts, create one dataset with all mountain totals
      const barData = mountains.map((mountain, idx) => {
        const data = weatherData[mountain.name][elevation].hourly;
        const values = hourlyIndices.map(i => data[config.dataKey][i]);
        return values.reduce((a, b) => a + b, 0);
      });

      const backgroundColors = mountains.map((m, idx) => colors[idx % colors.length].bg);
      const borderColors = mountains.map((m, idx) => colors[idx % colors.length].border);

      datasets = [{
        label: config.yAxisLabel,
        data: barData,
        backgroundColor: backgroundColors,
        borderColor: borderColors,
        borderWidth: 2
      }];

      chartData = {
        labels: mountains.map(m => m.name),
        datasets: datasets
      };
    } else {
      // For line charts, create one dataset per mountain
      datasets = mountains.map((mountain, idx) => {
        const data = weatherData[mountain.name][elevation].hourly;
        const values = hourlyIndices.map(i => data[config.dataKey][i]);
        const color = colors[idx % colors.length];

        return {
          label: mountain.name,
          data: values,
          backgroundColor: color.bg,
          borderColor: color.border,
          borderWidth: 2,
          fill: false,
          tension: 0.4,
          hidden: activeSeries !== null && activeSeries !== mountain.name
        };
      });

      chartData = {
        labels: labels,
        datasets: datasets
      };
    }

    const skiDayStart = config.type === 'bar' ? null : labels.indexOf('9:00');
    const skiDayEnd = config.type === 'bar' ? null : labels.indexOf('16:00');

    // Build annotations
    const annotations = {};

    // Add ski day shaded area for line charts
    if (config.type === 'line' && skiDayStart !== -1) {
      annotations.skiDay = {
        type: 'box',
        xMin: skiDayStart,
        xMax: skiDayEnd,
        backgroundColor: 'rgba(255, 215, 0, 0.1)',
        borderColor: 'rgba(255, 215, 0, 0.3)',
        borderWidth: 1
      };
    }

    // Add threshold lines for temperature and wind charts
    if (config.yAxisLabel === '¬∞F') {
      annotations.freezingLine = {
        type: 'line',
        yMin: 0,
        yMax: 0,
        borderColor: 'rgba(239, 68, 68, 0.8)',
        borderWidth: 2,
        borderDash: [6, 6],
        label: {
          display: true,
          content: '0¬∞F',
          position: 'end'
        }
      };
    }

    if (config.yAxisLabel === 'mph') {
      annotations.windThreshold = {
        type: 'line',
        yMin: 30,
        yMax: 30,
        borderColor: 'rgba(239, 68, 68, 0.8)',
        borderWidth: 2,
        borderDash: [6, 6],
        label: {
          display: true,
          content: '30 mph',
          position: 'end'
        }
      };
    }

    const chartOptions = {
      responsive: true,
      maintainAspectRatio: true,
      aspectRatio: config.type === 'bar' ? 1.5 : 4/3.6,
      onClick: (e, elements) => {
        if (config.type === 'line' && elements.length > 0) {
          const datasetIndex = elements[0].datasetIndex;
          const clickedMountain = mountains[datasetIndex].name;
          toggleSeriesSolo(clickedMountain);
        }
      },
      plugins: {
        legend: {
          display: config.type === 'line',
          position: 'top',
          onClick: (e, legendItem, legend) => {
            if (config.type === 'line') {
              const index = legendItem.datasetIndex;
              const clickedMountain = mountains[index].name;
              toggleSeriesSolo(clickedMountain);
            }
          }
        },
        tooltip: {
          mode: 'index',
          intersect: false
        },
        annotation: {
          annotations: annotations
        }
      },
      scales: {
        y: {
          beginAtZero: config.type === 'bar' ? true : false,
          title: {
            display: true,
            text: config.yAxisLabel
          }
        },
        x: {
          title: {
            display: config.type === 'line',
            text: 'Time'
          },
          ticks: {
            autoSkip: config.type === 'line' ? true : false,
            maxRotation: config.type === 'bar' ? 45 : 0,
            minRotation: config.type === 'bar' ? 45 : 0
          }
        }
      }
    };

    // Add bar-specific options
    if (config.type === 'bar') {
      chartOptions.barPercentage = 0.8;
      chartOptions.categoryPercentage = 0.9;
    }

    const chart = new Chart(ctx, {
      type: config.type,
      data: chartData,
      options: chartOptions
    });

    charts[config.id] = chart;
  }

  function toggleSeriesSolo(mountainName) {
    if (activeSeries === mountainName) {
      // Un-solo - show all
      activeSeries = null;
    } else {
      // Solo this mountain
      activeSeries = mountainName;
    }

    // Update all charts
    Object.values(charts).forEach(chart => {
      chart.data.datasets.forEach((dataset, idx) => {
        const datasetMountain = mountains[idx].name;
        dataset.hidden = activeSeries !== null && activeSeries !== datasetMountain;
      });
      chart.update();
    });
  }

  function updateElevationDisplay() {
    // Re-render comparison tables and charts with new elevation
    const startDate = $('#start-date').val();
    const endDate = $('#end-date').val();

    if (startDate && endDate && Object.keys(weatherData).length > 0) {
      renderResults(startDate, endDate);
    }
  }

  function showError(message) {
    $('#error-message').text(message);
    $('#error-modal').show();
  }

  // Make functions globally accessible
  window.deleteMountain = deleteMountain;
  window.editMountain = editMountain;
  window.saveMountainEdit = saveMountainEdit;
  window.cancelMountainEdit = cancelMountainEdit;
</script>
</body>
</html>
